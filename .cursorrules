---
description: 
alwaysApply: true
---

# FinTrack - AI Development Guidelines

## Project Overview

FinTrack is a React Native personal finance tracking mobile application. It uses TypeScript with strict mode, follows a Layered Architecture pattern, and stores all data locally (offline-first).

**Tech Stack:**

- React Native 0.83+ with New Architecture
- TypeScript (strict mode)
- RealmJS by MongoDB (local database)
- Jest for testing
- React Native Testing Library

## Architecture

**Layered Architecture:**

1. **Presentation Layer**: `components/` (flexibly organized), `screens/`, `navigation/`
2. **Business Logic Layer**: `hooks/`, `services/`
3. **Data Layer**: `store/`, `db/`
4. **Infrastructure Layer**: `utils/`, `theme/`, `constants/`, `assets/`, `localization/`

**Key Principles:**

- Separation of concerns: UI components are presentation-only
- Business logic lives in hooks and services
- Database accessed only through services (never directly from components)
- Dependencies point inward: screens → components → hooks/services → db
- Single responsibility: each module has one clear purpose
- Flexible component organization: organize by type, feature, or common/shared as needed

## Folder Structure & Where to Find Things

### Core Directories

- **`src/components/`** - UI components (flexibly organized)
  - Organize by type: `common/`, `forms/`, `cards/`, `lists/`
  - Or by feature: `transactions/`, `budgets/`, `categories/`
  - Or mix as needed for discoverability
- **`src/screens/`** - Screen components (compose components)
- **`src/hooks/`** - Custom React hooks (business logic, stored directly in hooks folder)
- **`src/services/`** - Business logic services (data operations)
- **`src/db/`** - Database layer (Realm schemas, models, migrations)
- **`src/navigation/`** - Navigation configuration
- **`src/utils/`** - Pure utility functions (stored directly in utils folder)
- **`src/contexts/`** - React Context providers (e.g., ThemeContext)
- **`src/theme/`** - Design tokens (colors, typography, spacing, shadows, createStyles)
- **`src/constants/`** - Application constants
- **`src/assets/`** - Static assets (fonts, images, SVG)
- **`src/localization/`** - i18n translations
- **`src/testUtils/`** - Testing utilities
- **`docs/adr/`** - ADR documents (read ADR-001 and ADR-002 for details)

### Module Structure Pattern

Every module follows this structure:

```
ModuleName/
  ├── __tests__/              # Test files
  │   └── ModuleName.test.tsx
  ├── __mocks__/              # Mock files
  │   └── ModuleName.module-mocks.ts
  ├── ModuleName.tsx          # Implementation
  ├── ModuleName.types.ts     # Types (if separate)
  ├── ModuleName.styles.ts    # Styles (if separate)
  └── index.ts                # Export
```

## Code Style & Conventions

### File Naming

- Components: `PascalCase.tsx` (e.g., `Button.tsx`)
- Screens: `PascalCase.tsx` (e.g., `HomeScreen.tsx`)
- Hooks: `useCamelCase.ts` (e.g., `useTransactions.ts`)
- Services: `camelCaseService.ts` (e.g., `transactionService.ts`)
- Utils: `camelCase.ts` (e.g., `formatCurrency.ts`)
- Tests: `*.test.tsx` or `*.test.ts`
- Styles: `*.styles.ts`

### Import Organization

1. External dependencies (React, React Native, third-party)
2. Internal absolute imports (by layer, alphabetical):
   - Navigation → Components → Contexts → Hooks → Services → Utils → Theme → Constants → Localization
3. Relative imports

**Use path aliases** (configured in `tsconfig.json`):

- `components/*`, `contexts/*`, `hooks/*`, `services/*`, `utils/*`, `screens/*`, etc.

### Code Formatting

- Prettier: single quotes, trailing commas, arrow parens: avoid
- ESLint: extends `@react-native`
- TypeScript: strict mode enabled

### Component Structure

```typescript
// 1. Imports (external → internal → relative)
import React, { FC } from 'react';
import { View } from 'react-native';
import { Button } from 'components/common';
import { useComponentStyles } from './Component.styles';

// 2. Types/Interfaces
interface IComponentProps {
  // props
}

// 3. Component
export const Component: FC<IComponentProps> = ({ ...props }) => {
  const styles = useComponentStyles();
  // logic
  return <View style={styles.container}>{/* JSX */}</View>;
};
```

### Styles Structure

Styles are created using `createStyles` from `theme`:

```typescript
// Component.styles.ts
import { TextStyle, ViewStyle } from 'react-native';
import { createStyles } from 'theme';

interface ComponentStyles {
  container: ViewStyle;
  text: TextStyle;
}

export const useComponentStyles = createStyles<ComponentStyles>(
  ({ theme, dimensions, insets }) => ({
    container: {
      backgroundColor: theme.colors.background.primary,
      padding: theme.spacing.lg,
      paddingTop: insets.top + theme.spacing.md,
    },
    text: {
      ...theme.typography.body,
      color: theme.colors.text.primary,
    },
  }),
);

// With extra data:
interface ComponentStylesExtra {
  isActive: boolean;
}

export const useComponentStyles = createStyles<
  ComponentStyles,
  ComponentStylesExtra
>(({ theme }, { isActive }) => ({
  container: {
    backgroundColor: isActive
      ? theme.colors.accent.green
      : theme.colors.background.primary,
  },
}));
```

### Service Structure

**All services are implemented as classes with static methods.**

- One class per service (e.g. `OnboardingStorageService`, `SecureStorageService`).
- Methods are **static** (no instance state; stateless services).
- Export the class and, for backward compatibility, function wrappers that delegate to the class.
- File name: `serviceNameService.ts` (e.g. `onboardingStorageService.ts`).
- Class name: `PascalCaseStorageService` or `PascalCaseService`.

```typescript
// serviceNameService.ts
export class ServiceNameService {
  static async getSomething(): Promise<T> {
    // ...
  }
  static async setSomething(value: T): Promise<void> {
    // ...
  }
}

// Backward-compatible function exports
export const getSomething = ServiceNameService.getSomething.bind(ServiceNameService);
export const setSomething = ServiceNameService.setSomething.bind(ServiceNameService);
```

When adding a **new** service, always create a class first; then export the class and optional function wrappers from the module.

### Animations

**Always use `react-native-reanimated` for animations.** Do not use React Native's built-in `Animated` API.

- Use `useSharedValue`, `useAnimatedStyle`, `withTiming` / `withSpring`, and `Animated.View` (and other `Animated.*` components) from `react-native-reanimated`.
- Animations run on the UI thread for better performance.
- For new animations, follow existing patterns (e.g. `OnboardingScreen` slide/fade).
- See `docs/conventions/animations.md` for details.

## Component Organization Rules

**Organization Strategy:**

- Organize components by purpose, type, or feature as makes sense
- Common patterns: `components/common/`, `components/forms/`, `components/cards/`, `components/lists/`
- Feature-specific: `components/transactions/`, `components/budgets/` (if needed)
- Prioritize discoverability and logical grouping
- No strict hierarchy or dependency rules between component folders
- Components can import from other components as needed
- Focus on reusability through good design, not enforced structure

**Dependency Rule:**

- Screens compose components and use hooks/services
- Components can use other components, hooks, and services
- No enforced dependency rules between component folders

## Testing Requirements

**ALWAYS:**

- Write tests for new components, hooks, services, and utilities
- Place tests in `__tests__/` folder co-located with source
- Use React Native Testing Library for component tests
- Mock external dependencies in `__mocks__/` folders
- Test files follow naming: `ModuleName.test.tsx` or `ModuleName.test.ts`

**Test Structure:**

- Import mocks at the top of test files
- Use descriptive test names
- Test user interactions, not implementation details

## Do's and Don'ts

### DO:

- ✅ Follow the layered architecture (components → hooks → services → db)
- ✅ Organize components flexibly (by type, feature, or common/shared)
- ✅ Create tests for all new code
- ✅ Use path aliases for imports
- ✅ Export from `index.ts` files
- ✅ Use TypeScript strict typing
- ✅ Place business logic in hooks/services, not components
- ✅ Access database only through services
- ✅ Implement services as classes with static methods (see Service Structure)
- ✅ Use react-native-reanimated for all animations (see Animations)
- ✅ Use theme constants for colors/spacing
- ✅ Use `createStyles` from `theme` to create style hooks
- ✅ Use the app **Text** component (`components/common/Text`) for all UI text; use **compound syntax** (`Text.H1`, `Text.H2`, `Text.Body`, `Text.Button`, etc.), not `<Text variant="…">`—see `docs/conventions/text-component.md`
- ✅ Each component should have its own style hook (e.g., `useComponentStyles`)
- ✅ Use localization for all user-facing text
- ✅ Follow the module structure pattern (tests, mocks, implementation)
- ✅ Read ADR documents in `docs/adr/` for architectural decisions
- ✅ Prioritize component discoverability and logical grouping

### DON'T:

- ❌ Import database directly from components (use services)
- ❌ Add new services as standalone functions only (use a class with static methods)
- ❌ Use React Native's Animated API for new code (use react-native-reanimated)
- ❌ Put business logic in components
- ❌ Use relative imports when path aliases are available
- ❌ Skip writing tests
- ❌ Hardcode strings (use localization)
- ❌ Hardcode colors/spacing (use theme)
- ❌ Use React Native's `Text` for app UI (use `Text` from `components` / `components/common` instead)
- ❌ Use `<Text variant="…">` (use compound components: `Text.H2`, `Text.Body`, `Text.Button`, etc.)
- ❌ Use StyleSheet.create directly (use createStyles instead)
- ❌ Create files outside the established structure
- ❌ Mix concerns (UI + business logic + data access)
- ❌ Overthink component organization - start simple, refactor as patterns emerge

## Where to Look for Specific Things

- **Architecture decisions**: `docs/adr/ADR-001-high-level-architecture.md`, `ADR-002.md`
- **Service conventions** (class-based services): `docs/conventions/services.md`, `src/services/secureStorageService/`
- **Animation conventions** (Reanimated only): `docs/conventions/animations.md`, `src/screens/OnboardingScreen/OnboardingScreen.tsx`
- **Text component** (use for all UI text): `docs/conventions/text-component.md`, `src/components/common/Text/`
- **Component examples**: `src/screens/HelloWorld/` (shows full module structure)
- **TypeScript config**: `tsconfig.json` (path aliases, baseUrl)
- **Test examples**: `src/screens/HelloWorld/__tests__/`
- **Mock examples**: `src/screens/HelloWorld/__mocks__/`
- **Project spec**: `fintrack-spec-en.md`
- **PRD**: `fintrack-prd-en.md`

## Common Tasks

**Adding a new component:**

1. Decide organization (common, forms, cards, lists, or feature-specific)
2. Create folder: `components/{organization}/ComponentName/` (e.g., `components/common/Button/`)
3. Follow module structure pattern (tests, mocks, implementation)
4. Export from `components/{organization}/index.ts` or `components/index.ts`

**Adding a new screen:**

1. Create folder: `screens/ScreenName/`
2. Follow module structure pattern
3. Compose using components from `components/`
4. Export from `screens/index.ts`

**Adding a new hook:**

1. Create file: `hooks/useHookName.ts`
2. Encapsulate business logic
3. Export from `hooks/index.ts`

**Adding a new service:**

1. Create folder: `services/serviceNameService/`
2. **Implement as a class** with static methods (e.g. `export class TransactionService { static create(...) { ... } }`).
3. Export the class and, if needed, function wrappers for backward compatibility.
4. Follow module structure pattern (__tests__, __mocks__, implementation, index.ts).
5. Abstract data access (use `db/` layer).
6. Export from `services/index.ts`

## Important Notes

- **Database**: RealmJS - accessed ONLY through services, never directly from components
- **State Management**: Redux Toolkit (see ADR-003)
- **Navigation**: To be decided (see navigation-map)
- **Offline-first**: All data stored locally, no cloud sync
- **Security**: PIN/biometric auth, secure local storage
- **Performance**: Fast transaction entry (<500ms), smooth scrolling (≥55 FPS)

## When in Doubt

1. Check existing code in `src/screens/HelloWorld/` for structure examples
2. Read ADR documents in `docs/adr/`
3. Follow the established patterns - consistency is key
4. When adding new code, match the existing module structure exactly
