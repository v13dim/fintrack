# ADR-001: Architectural Approach

## Status

Accepted

## Context

FinTrack is a personal finance tracking mobile application built with React Native. The project serves as a training exercise to develop skills in architectural decision-making, clean code practices, and production-ready mobile development.

Key requirements and constraints:

- **Platform**: React Native 0.76+ with New Architecture enabled
- **Language**: TypeScript with strict mode
- **Data Privacy**: All data stored locally on device only (no cloud sync)
- **Performance**: Fast transaction entry (<500ms), smooth scrolling (≥55 FPS)
- **Offline-first**: Application must work entirely offline
- **Security**: PIN/biometric authentication, secure local storage
- **Maintainability**: Code must be well-organized, testable, and documented
- **Team Size**: Solo developer initially, but code should be team-ready

The application needs to handle:

- User authentication (PIN/biometrics)
- Transaction CRUD operations
- Category management
- Budget tracking
- Analytics and reporting
- Data export/import

## Considered Options

### Option A: Monolithic Component Architecture

- ✅ Simple to start
- ✅ Fast initial development
- ❌ Difficult to scale
- ❌ Hard to test individual pieces
- ❌ Poor code reusability
- ❌ Violates separation of concerns

### Option B: Feature-Based Architecture

```
src/
  features/
    transactions/
      components/
      hooks/
      services/
      types/
    categories/
      ...
```

- ✅ Clear feature boundaries
- ✅ Good for large teams
- ✅ Features are self-contained
- ❌ Potential code duplication across features
- ❌ May be overkill for a solo project
- ❌ Harder to share common components

### Option C: Layered Architecture with Atomic Design (Selected)

```
src/
  components/ (Atomic Design: atoms, molecules, organisms)
  screens/
  navigation/
  hooks/
  services/
  store/
  db/
  api/
  utils/
  theme/
  constants/
```

- ✅ Clear separation of concerns
- ✅ Reusable component hierarchy
- ✅ Easy to test each layer independently
- ✅ Scales well as project grows
- ✅ Aligns with React Native best practices
- ✅ Component reusability through Atomic Design
- ❌ Requires discipline to maintain boundaries
- ❌ Slightly more initial setup

### Option D: Domain-Driven Design (DDD)

- ✅ Excellent for complex business logic
- ✅ Clear domain boundaries
- ❌ Over-engineered for this project scope
- ❌ Steeper learning curve
- ❌ More ceremony than needed

## Decision

We will adopt **Layered Architecture with Atomic Design** (Option C).

### Architecture Layers

1. **Presentation Layer** (`components/`, `screens/`, `navigation/`)

   - Atomic Design pattern: atoms → molecules → organisms
   - Screens compose organisms and molecules
   - Navigation configuration and routing setup
   - Container/Presentation pattern for logic separation

2. **Business Logic Layer** (`hooks/`, `services/`)

   - Custom hooks encapsulate business logic
   - Services handle data operations and business rules
   - Pure functions where possible

3. **Data Layer** (`store/`, `db/`, `api/`)

   - State management (to be decided in ADR-003)
   - Local database: **RealmJS by MongoDB** (`db/`)
     - Object-oriented database for local-first architecture
     - Schema definitions, models, and database configuration
     - Realm queries and data access patterns
     - Automatic persistence and real-time updates
   - API layer (currently empty, reserved for future)

4. **Infrastructure Layer** (`utils/`, `theme/`, `constants/`, `assets/`)
   - Shared utilities and helpers
   - Theme configuration
   - Constants and configuration
   - Static assets (images, fonts, SVG icons)

### Component Organization (Atomic Design)

```
components/
  atoms/          # Basic building blocks (Button, Input, Text)
  molecules/      # Simple combinations (FormField, TransactionItem)
  organisms/      # Complex components (TransactionList, BudgetCard)
  index.ts        # Public API exports
```

**Principles:**

- Atoms are the smallest, most reusable components
- Molecules combine atoms for specific use cases
- Organisms combine molecules and atoms for complex UI sections
- Each level can only import from lower levels (atoms can't import molecules)

### Code Organization Principles

1. **Separation of Concerns**

   - UI components are presentation-only
   - Business logic lives in hooks and services
   - Data access is abstracted through services

2. **Single Responsibility Principle**

   - Each component/hook/service has one clear purpose
   - Functions do one thing well

3. **Dependency Rule**

   - Dependencies point inward: screens → organisms → molecules → atoms
   - Navigation is used by screens, but screens don't depend on navigation internals
   - Services and hooks can be used by any layer
   - Database layer (`db/`) is accessed through services, not directly from components
   - Utils are shared utilities with no dependencies

4. **Testability**

   - Pure functions for business logic
   - Dependency injection for services
   - Components are easily testable in isolation

5. **Type Safety**

   - TypeScript strict mode enabled
   - All functions and components are typed
   - Shared types in appropriate locations

### Technology Stack Decisions

- **Framework**: React Native 0.83+ with New Architecture
- **Language**: TypeScript (strict mode)
- **Database**: RealmJS by MongoDB (local-first, object database)
- **State Management**: To be decided (ADR-003)
- **Navigation**: To be decided (ADR-006)

### Design Patterns to Apply

1. **Container/Presentation Pattern**

   - Separate data/logic containers from presentational components
   - Improves testability and reusability

2. **Custom Hooks Pattern**

   - Encapsulate business logic in reusable hooks
   - Examples: `useTransactions`, `useBudgets`, `useAuth`

3. **Provider Pattern**

   - Theme provider, Auth provider
   - Context for cross-cutting concerns

4. **Compound Components**

   - For complex UI patterns (forms, lists)
   - Improves API flexibility

5. **Render Props / HOC** (at least one example)
   - For cross-cutting functionality
   - To be determined based on use case

## Consequences

### Positive

1. **Maintainability**

   - Clear structure makes it easy to find and modify code
   - New developers can understand the codebase quickly

2. **Testability**

   - Each layer can be tested independently
   - Business logic is separated from UI

3. **Reusability**

   - Atomic Design promotes component reuse
   - Shared utilities reduce duplication

4. **Scalability**

   - Easy to add new features without restructuring
   - Clear boundaries prevent coupling

5. **Team Readiness**
   - Structure supports multiple developers
   - Clear conventions reduce conflicts

### Negative / Trade-offs

1. **Initial Overhead**

   - More files and folders to navigate
   - Requires discipline to maintain boundaries
   - **Mitigation**: Clear documentation and examples

2. **Potential Over-Engineering**

   - Some simple features might feel over-structured
   - **Mitigation**: YAGNI principle - don't create abstractions until needed

3. **Learning Curve**

   - Team members need to understand Atomic Design
   - **Mitigation**: Documentation and code examples

4. **File Navigation**
   - More files to navigate
   - **Mitigation**: Good IDE support, clear naming conventions

### Risks and Mitigations

| Risk                  | Impact | Mitigation                                 |
| --------------------- | ------ | ------------------------------------------ |
| Boundary violations   | Medium | Linting rules, code reviews, documentation |
| Over-abstraction      | Low    | Apply YAGNI, refactor when needed          |
| Inconsistent patterns | Medium | Establish conventions early, use examples  |

## References

- [React Native Architecture](https://reactnative.dev/docs/the-new-architecture/landing-page)
- [Atomic Design Methodology](https://bradfrost.com/blog/post/atomic-web-design/)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [React Design Patterns](https://refine.dev/blog/react-design-patterns/)
- [ADR GitHub](https://adr.github.io/)
- Project Specification: `fintrack-spec-en.md`
- Project PRD: `fintrack-prd-en.md`
